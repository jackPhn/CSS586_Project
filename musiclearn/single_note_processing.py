import glob
import pathlib
import pickle
import numpy as np
import sys
import os
from music21 import *


def read_midi(midi_dir):
    """ Read all midi file in a collection and return the notes """
    notes = []
    
    noteFile_dir = str(midi_dir) + "/notes"
    
    if not os.path.exists(noteFile_dir):
        files_dir = str(midi_dir) + "/*.mid"
        for file in glob.glob(files_dir):
            midi = converter.parse(file)

            print("Parsing %s" % file)

            notes_to_parse = None

            try: # file has instrument parts
                s2 = instrument.partitionByInstrument(midi)
                
                # looping over all the instrument parts
                for part in s2.parts:
                    #select elements of piano
                    if "Piano" in str(part):
                        notes_to_parse = part.recurse()
            except: # file has notes in a flat structure
                notes_to_parse = midi.flat.notes

            # if there are notes to parse
            if notes_to_parse is not None:
                for element in notes_to_parse:
                    if isinstance(element, note.Note):
                         notes.append(str(element.pitch))
                    elif isinstance(element, chord.Chord):
                        notes.append('.'.join(str(n) for n in element.normalOrder))

        # save the note to file
        with open(noteFile_dir, 'wb') as fp:
            pickle.dump(notes, fp)
    else:
        with open(noteFile_dir, 'rb') as fp:
            notes = pickle.load(fp)
    return notes


def get_unique_notes(notes):
    """ Return a sorted set of unique notes """
    pitchNames = sorted(set(item for item in notes))
    return pitchNames
    

def get_num_unique_notes(notes):
    """ Return the number of unique notes"""
    pitchNames = get_unique_notes(notes)
    n_vocab = len(pitchNames)
    return n_vocab


def map_note_to_int(notes):
    """ Map unique notes to unique integers """
    # find the unique notes
    pitchNames = get_unique_notes(notes)
    # create a dictionary to map notes to unique integers
    note_to_int = dict((note, number) for number, note in enumerate(pitchNames))
    return note_to_int


def map_int_to_notes(notes):
    """ Map unique notes to unique integers """
    # find the unique notes
    pitchNames = get_unique_notes(notes)
    # create a dictionary to map unique integers to notes
    int_to_note = dict((number, note) for number, note in enumerate(pitchNames))
    return int_to_note


def prepare_sequences(sequence_length, notes):
    """ Prepare the sequences used by the neural network """   
    network_input = []
    network_output = []
    
    # get the nunber of unique notes
    n_vocab = len(get_unique_notes(notes))
    
    # map the notes to unique integers
    note_to_int = map_note_to_int(notes)
    
    # create input sequences and the corresponding outputs
    for i in range(0, len(notes) - sequence_length, 1):
        sequence_in = notes[i : i + sequence_length]
        sequence_out = notes[i + sequence_length]
        network_input.append([note_to_int[char] for char in sequence_in])
        network_output.append(note_to_int[sequence_out])
        
    n_samples = len(network_input)
    
    # reshape the input into a format compatible with LSTM layers
    network_input = np.reshape(network_input, (n_samples, sequence_length, 1))
    # normalize input
    network_input = network_input / float(n_vocab)
    
    network_output = np.array(network_output)
    
    return (network_input, network_output)


def create_midi(notes_list, filename):
    """ Convert a list of notes into a MIDI file and save to .mid file"""
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in notes_list:
        # pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 1

    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp=filename + '.mid')
 



